// Cache para as configura√ß√µes
let configCache: any = null
let cacheTimestamp = 0
const CACHE_DURATION = 30000 // 30 segundos

// Fun√ß√£o para obter configura√ß√µes do servidor
export async function getConfig() {
  // Se j√° temos cache v√°lido e estamos no cliente, usar cache
  const now = Date.now()
  if (configCache && typeof window !== "undefined" && now - cacheTimestamp < CACHE_DURATION) {
    console.log("üîß Using cached client config")
    return configCache
  }

  // No servidor, ler diretamente das vari√°veis de ambiente (SEM NEXT_PUBLIC_)
  if (typeof window === "undefined") {
    const config = {
      supabaseUrl: process.env.SUPABASE_URL || "http://localhost:54321",
      supabaseAnonKey: process.env.SUPABASE_ANON_KEY || "dummy-key",
      nextAuthUrl: process.env.NEXTAUTH_URL || "http://localhost:3000",
      customKey: process.env.CUSTOM_KEY || "",
    }

    console.log("üîß Server config loaded:")
    console.log("Supabase URL:", config.supabaseUrl)
    console.log("NextAuth URL:", config.nextAuthUrl)
    console.log("Custom Key:", config.customKey ? "‚úÖ Defined" : "‚ùå Not defined")

    return config
  }

  // No cliente, buscar da API
  try {
    console.log("üåê Client fetching config from /api/config...")
    const response = await fetch("/api/config", {
      cache: "no-store", // Sempre buscar dados frescos
      headers: {
        "Cache-Control": "no-cache",
      },
    })

    if (!response.ok) {
      console.error(`‚ùå Failed to fetch config: ${response.status} ${response.statusText}`)
      throw new Error(`Failed to fetch config: ${response.status}`)
    }

    const config = await response.json()

    // Cache no cliente
    configCache = config
    cacheTimestamp = now

    console.log("üîß Client config loaded from /api/config:")
    console.log("Supabase URL:", config.supabaseUrl)
    console.log("NextAuth URL:", config.nextAuthUrl)

    return config
  } catch (error) {
    console.error("‚ùå Failed to load config from /api/config:", error)

    // Fallback apenas para desenvolvimento local
    if (typeof window !== "undefined" && window.location.hostname === "localhost") {
      const fallbackConfig = {
        supabaseUrl: "http://localhost:54321",
        supabaseAnonKey: "dummy-key",
        nextAuthUrl: "http://localhost:3000",
        customKey: "",
      }
      console.log("üîß Using localhost fallback config")
      configCache = fallbackConfig
      cacheTimestamp = now
      return fallbackConfig
    }

    // Em produ√ß√£o, n√£o usar fallback - deixar falhar para debug
    throw error
  }
}

// Fun√ß√£o para limpar cache (√∫til para testes)
export function clearConfigCache() {
  configCache = null
  cacheTimestamp = 0
  console.log("üßπ Config cache cleared")
}

// Fun√ß√£o para verificar se as configura√ß√µes est√£o v√°lidas
export function validateConfig(config: any): boolean {
  if (!config.supabaseUrl || config.supabaseUrl.includes("placeholder")) {
    console.error("‚ùå Invalid Supabase URL:", config.supabaseUrl)
    return false
  }

  if (!config.supabaseAnonKey || config.supabaseAnonKey === "dummy-key") {
    console.error("‚ùå Invalid Supabase Anon Key")
    return false
  }

  if (!config.nextAuthUrl || config.nextAuthUrl.includes("placeholder")) {
    console.error("‚ùå Invalid NextAuth URL:", config.nextAuthUrl)
    return false
  }

  return true
}
